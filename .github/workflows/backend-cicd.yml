name: Backend CI/CD

on:
  workflow_dispatch:  # Allows manual triggering from GitHub Actions UI
  push:
    branches: [ "main", "dev" ]
    paths:
      - './src/backend/**' 
      - './contrib/container/docker-compose.dev.yml'
      - './contrib/container/Dockerfile'
      - './.github/workflows/backend-cicd.yml'
  pull_request:
    branches: [ "main", "dev" ]
    paths:
      - './src/backend/**'
      - './contrib/container/docker-compose.dev.yml'
      - './contrib/container/Dockerfile'
      - './.github/workflows/backend-cicd.yml'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: docker.io
  IMAGE_NAME: otask-backend
  PYTHON_VERSION: "3.12"
  COVERAGE_THRESHOLD: "80"

jobs:
  lint-and-format:
    name: Lint and Format Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Cache linting dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-linting-${{ hashFiles('src/backend/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-linting-

      - name: Install linting dependencies
        working-directory: ./src/backend
        run: |
          python -m pip install --upgrade pip
          pip install black flake8 isort mypy

      - name: Check code formatting with black
        working-directory: ./src/backend
        run: black --check --diff .

      - name: Check import sorting with isort
        working-directory: ./src/backend
        run: isort --check-only --diff .

      - name: Lint with flake8
        working-directory: ./src/backend
        run: flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics

      - name: Type check with mypy (optional)
        working-directory: ./src/backend
        continue-on-error: true
        run: mypy . --ignore-missing-imports || echo "Type checking skipped or failed"

  quality-check:
    name: Quality Check and Tests
    runs-on: ubuntu-latest
    needs: lint-and-format
    timeout-minutes: 45
    
    services:
      postgres:
        image: postgres:17
        env:
          POSTGRES_DB: ${{ secrets.DB_NAME || 'test_db' }}
          POSTGRES_USER: ${{ secrets.DB_USER || 'test_user' }}
          POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD || 'test_password' }}
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create .env file
        run: |
          echo "${{ secrets.CI_ENV }}" > ./contrib/container/docker.dev.env
          if [ ! -f ./contrib/container/docker.dev.env ]; then
            echo "Error: .env file was not created"
            exit 1
          fi

      - name: Build Docker image for testing
        id: build-test-image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./contrib/container/Dockerfile
          push: false
          tags: ${{ env.IMAGE_NAME }}:test
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: Wait for PostgreSQL to be ready
        run: |
          until pg_isready -h localhost -p 5432 -U ${{ secrets.DB_USER || 'test_user' }}; do
            echo "Waiting for PostgreSQL..."
            sleep 2
          done
          echo "PostgreSQL is ready!"

      - name: Wait for Redis to be ready
        run: |
          until redis-cli -h localhost -p 6379 ping; do
            echo "Waiting for Redis..."
            sleep 2
          done
          echo "Redis is ready!"

      - name: Run Database Migrations
        run: |
          docker run --rm \
            --network host \
            -e POSTGRES_HOST=localhost \
            -e POSTGRES_PORT=5432 \
            -e POSTGRES_DB=${{ secrets.DB_NAME || 'test_db' }} \
            -e POSTGRES_USER=${{ secrets.DB_USER || 'test_user' }} \
            -e POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD || 'test_password' }} \
            -e REDIS_URL=redis://localhost:6379/0 \
            --env-file ./contrib/container/docker.dev.env \
            ${{ env.IMAGE_NAME }}:test \
            python manage.py migrate --no-input

      - name: Run Unit Tests with Coverage and JUnit XML Output
        id: tests
        run: |
          mkdir -p test-results
          
          docker run --rm \
            --network host \
            -e POSTGRES_HOST=localhost \
            -e POSTGRES_PORT=5432 \
            -e POSTGRES_DB=${{ secrets.DB_NAME || 'test_db' }} \
            -e POSTGRES_USER=${{ secrets.DB_USER || 'test_user' }} \
            -e POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD || 'test_password' }} \
            -e REDIS_URL=redis://localhost:6379/0 \
            --env-file ./contrib/container/docker.dev.env \
            -v ${{ github.workspace }}/test-results:/app/test-results \
            ${{ env.IMAGE_NAME }}:test \
            sh -c "
              set -e
              coverage run --source='.' \
                --omit='*/migrations/*,*/venv/*,*/env/*,*/__pycache__/*,*/tests.py,*/test_*.py,manage.py' \
                python manage.py test \
                  --verbosity=2 \
                  --no-input \
                  --testrunner=xmlrunner.extra.djangotestrunner.XMLTestRunner \
                  --output-file=/app/test-results/test-results.xml && \
              coverage xml -o /app/test-results/coverage.xml && \
              coverage report --show-missing
            "
        continue-on-error: false
        timeout-minutes: 30

      - name: Parse and Display Test Results
        if: always()
        run: |
          if [ -f test-results/test-results.xml ]; then
            echo "## Test Results Summary" >> $GITHUB_STEP_SUMMARY
            tests=$(grep -o 'tests="[0-9]*"' test-results/test-results.xml | head -1 | grep -o '[0-9]*' || echo "N/A")
            failures=$(grep -o 'failures="[0-9]*"' test-results/test-results.xml | head -1 | grep -o '[0-9]*' || echo "0")
            errors=$(grep -o 'errors="[0-9]*"' test-results/test-results.xml | head -1 | grep -o '[0-9]*' || echo "0")
            echo "- **Total Tests:** $tests" >> $GITHUB_STEP_SUMMARY
            echo "- **Failures:** $failures" >> $GITHUB_STEP_SUMMARY
            echo "- **Errors:** $errors" >> $GITHUB_STEP_SUMMARY
          else
            echo "## Test Results" >> $GITHUB_STEP_SUMMARY
            echo "⚠️ Test results file not found" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Check Coverage Threshold
        if: always()
        run: |
          if [ -f test-results/coverage.xml ]; then
            coverage=$(grep -o 'line-rate="[0-9.]*"' test-results/coverage.xml | head -1 | grep -o '[0-9.]*' || echo "0")
            coverage_percent=$(echo "$coverage * 100" | bc | cut -d. -f1)
            threshold=${{ env.COVERAGE_THRESHOLD }}
            
            echo "## Coverage Report" >> $GITHUB_STEP_SUMMARY
            echo "- **Coverage:** ${coverage_percent}%" >> $GITHUB_STEP_SUMMARY
            echo "- **Threshold:** ${threshold}%" >> $GITHUB_STEP_SUMMARY
            
            if [ "$coverage_percent" -lt "$threshold" ]; then
              echo "❌ Coverage ${coverage_percent}% is below threshold ${threshold}%" >> $GITHUB_STEP_SUMMARY
              echo "Coverage threshold check failed!"
              exit 1
            else
              echo "✅ Coverage meets threshold requirement" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "## Coverage Report" >> $GITHUB_STEP_SUMMARY
            echo "⚠️ Coverage file not found" >> $GITHUB_STEP_SUMMARY
            echo "Coverage check skipped"
          fi

      - name: Upload test results and coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-and-coverage
          path: |
            test-results/test-results.xml
            test-results/coverage.xml
          retention-days: 30
          if-no-files-found: ignore

      - name: Copy test results and coverage to SonarQube project directory
        if: success()
        run: |
          mkdir -p ./src/backend/otaskmanagement/test-results
          if [ -f test-results/test-results.xml ]; then
            cp test-results/test-results.xml ./src/backend/otaskmanagement/test-results/test-results.xml
            echo "Test results copied successfully"
          else
            echo "Warning: Test results file not found"
          fi
          if [ -f test-results/coverage.xml ]; then
            cp test-results/coverage.xml ./src/backend/otaskmanagement/coverage.xml
            echo "Coverage file copied successfully"
          else
            echo "Warning: Coverage file not found"
          fi

      - name: SonarQube Scan
        if: success()
        uses: SonarSource/sonarqube-scan-action@v6
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN_BE }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        with:
          projectBaseDir: ./src/backend/otaskmanagement
          args: >
            -Dsonar.testExecutionReportPaths=test-results/test-results.xml
            -Dsonar.python.coverage.reportPaths=coverage.xml
            -Dsonar.projectVersion=${{ github.ref_name }}-${{ github.sha }}

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: lint-and-format
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.29.0
        with:
          scan-type: 'fs'
          scan-ref: './src/backend'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
          wait-for-processing: true

  build-and-push:
    name: Build and Push Docker Image
    needs: [quality-check, security-scan]
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and Push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./contrib/container/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
          platforms: linux/amd64,linux/arm64

      - name: Image digest and tags
        if: success()
        run: |
          echo "## Docker Image Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Digest:** ${{ steps.build.outputs.digest }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tags:** ${{ steps.meta.outputs.tags }}" >> $GITHUB_STEP_SUMMARY
          echo "Image pushed successfully!"

  smoke-test:
    name: Smoke Test
    needs: build-and-push
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    services:
      postgres:
        image: postgres:17
        env:
          POSTGRES_DB: test_db
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Docker and curl
        run: |
          sudo apt-get update
          sudo apt-get install -y curl || true

      - name: Pull and run image
        id: run-container
        run: |
          docker pull ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }} || \
          docker pull ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          
          CONTAINER_ID=$(docker run -d --name test-container \
            --network host \
            -e POSTGRES_HOST=localhost \
            -e POSTGRES_DB=test_db \
            -e POSTGRES_USER=test_user \
            -e POSTGRES_PASSWORD=test_password \
            ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }} || \
            ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest)
          
          echo "container_id=$CONTAINER_ID" >> $GITHUB_OUTPUT
          echo "Container started: $CONTAINER_ID"

      - name: Wait for application to start
        run: |
          echo "Waiting for application to be ready..."
          for i in {1..30}; do
            if curl -f http://localhost:8000/admin/ 2>/dev/null; then
              echo "Application is ready!"
              exit 0
            fi
            echo "Attempt $i/30: Application not ready yet..."
            sleep 2
          done
          echo "Application failed to start within timeout"
          exit 1

      - name: Health check
        run: |
          docker exec test-container python manage.py check --deploy || exit 1
          curl -f http://localhost:8000/admin/ || exit 1
          echo "✅ Health checks passed!"

      - name: Cleanup
        if: always()
        run: |
          docker stop test-container || true
          docker rm -f test-container || true
          echo "Cleanup completed"
